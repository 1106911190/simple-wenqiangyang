---
layout: post
title: 面试总结
category: project
description: 在 Python 方面和工作方面的面试总结
---

## 数据库三大范式

第一范式就是原子性，字段不可再分割； 数据库中表的每一列都不可分割
第二范式就是完全依赖，没有部分依赖； 数据库中表的每一列都完全依赖于主键
第三范式就是没有传递依赖。           数据库中表的每一列没有传递依赖

符合第一范式和第二范式，为了性能可以违反了第三范式。

## redis 使用优化

redis 典型的数据类型有 字符串，数组，集合，字典（哈希），有序集合。

redis 的使用场景 数据库，缓存，任务队列的输入和输出等

优化总结

1. 根据业务需要选择合适的数据类型，并为不同的应用场景设置相应的紧凑存储参数。
2. 当业务场景不需要数据持久化时，关闭所有的持久化方式可以获得最佳的性能以及最大的内存使用量。
3. 如果需要使用持久化，根据是否可以容忍重启丢失部分数据在快照方式与语句追加方式之间选择其一，不要使用虚拟内存以及diskstore方式。
> 定时快照仍是存储在内存中，故重启即丢失。语句追加即存储在磁盘文件中，但将每一个命令语句都存储，加载较慢。
4. 不要让你的Redis所在机器物理内存使用超过实际内存总量的3/5。

## MySQL 使用优化

MySQL 存储引擎 InnoDB 和 MyISAM，区别是 MyISAM 没有事务支持，没有外键支持，数据库数据分三个文件存储，在大数据量的情况下使用 InnoDB 更好，但是 MyISAM 有索引缓存，可以全文索引，所以查询检索更快，全文搜索更好。

数据库索引在查找字段上，如果有多个查询条件的情况下，可以使用联合索引，但是使用联合索引的情况下需注意符合最左前缀匹配原则，否则反而可能影响性能。

尽量避免使用外键，保证事务一致性应由业务层去完成，而不是数据库层。因为在数据量大，并发数高的情况下，数据库使用外键操作速度慢，不易水平扩展，容易出现死锁，需要做相关检查。数据库本来就是性能瓶颈，去掉外键更加灵活。

不用外键，则不用联合查询，因为使用联合查询也慢。使用 ORM 的时候，将需要联合查询的字段取出来做程序处理，在设计时可以在 model 层抽象出来作为属性使用。

减少互质操作，减少表锁定等待。 InnoDB 是行锁定， MyISAM 是表锁定。比如使用 MyISAM 的 update ，相互操作之间是相互锁定的。数据库引擎选择上在大量查找操作的时候用 MyISAM ，在大量插入更新操作的时候使用 InnoDB .

## 缓存优化

更新缓存时先更新数据库再刷新缓存。

最好的方法是直接更新缓存，因为快。再通过缓存异步更新数据库。

## 应用解耦的好处

1. 抽象，模块化，易于查找，分析问题，便于更换改动，维护成本低，可读性高。
2. 代码复用，模块封装。
3. 低耦合，高内聚。模块之间低耦合，模块内部高内聚。

## web 站点性能优化

1. 提高服务器并发处理能力，多线程，多进程，异步 等
2. 动态内容服务器端缓存
3. 静态内容分布式缓存
4. 浏览器缓存
5. web 服务器缓存和反向代理缓存
6. 前端静态文本内容压缩，域名分离提高并发数
7. 数据库性能优化
8. 负载均衡
9. 动态脚本加速

## 在前后端分离中怎么做登陆状态控制，怎么做跨站请求，怎么做 CSRF 防护。

在登陆控制可以用 cookies 或者 token ，登陆状态由后端 session 保存。

用 CROS 做跨站请求，对请求资源做请求来源限制。

CSRF 防护原理和控制

## flask 启动流程

上下文处理流程，一个程序上下文中有很多的请求上下文，在每一个请求上下文是相互独立的，在 `__storage__` 中保存了不同线程的状态，在 flask 中，有线程，也有协程。

在接收到请求之后，首先根据 WSGI 发送的 environ 变量获取

flask 中的钩子有 `before_request`, `before_first_request`, `after_request`, `teardown_request`, `teardown_appcontext`, `context_processor` after 和 teardown 的区别是 前者只在正常处理请求之后执行，teardown 则无论是否发生异常，都执行。

## Python 内存管理

从三个方面来说,一对象的引用计数机制,二垃圾回收机制,三内存池机制

一、对象的引用计数机制
python内部使用引用计数，来保持追踪内存中的对象，所有对象都有引用计数。
引用计数增加的情况：
1，一个对象分配一个新名称
2，将其放入一个容器中（如列表、元组或字典）
引用计数减少的情况：
1，使用del语句对对象别名显示的销毁
2，引用超出作用域或被重新赋值
sys.getrefcount( )函数可以获得对象的当前引用计数
多数情况下，引用计数比你猜测得要大得多。对于不可变数据（如数字和字符串），解释器会在程序的不同部分共享内存，以便节约内存。
二、垃圾回收
1，当一个对象的引用计数归零时，它将被垃圾收集机制处理掉。
2，当两个对象a和b相互引用时，del语句可以减少a和b的引用计数，并销毁用于引用底层对象的名称。然而由于每个对象都包含一个对其他对象的应用，因此引用计数不会归零，对象也不会销毁。（从而导致内存泄露）。为解决这一问题，解释器会定期执行一个循环检测器，搜索不可访问对象的循环并删除它们。
三、内存池机制
Python提供了对内存的垃圾收集机制，但是它将不用的内存放到内存池而不是返回给操作系统。
1，Pymalloc机制。为了加速Python的执行效率，Python引入了一个内存池机制，用于管理对小块内存的申请和释放。
2，Python中所有小于256个字节的对象都使用pymalloc实现的分配器，而大的对象则使用系统的malloc。
3，对于Python对象，如整数，浮点数和List，都有其独立的私有内存池，对象间不共享他们的内存池。也就是说如果你分配又释放了大量的整数，用于缓存这些整数的内存就不能再分配给浮点数。

## 线程跟协程的关系

## 协程与异步 IO 的关系

比如异步 IO 库 twisted 和 协程库 greenlet

## 新式类与旧式类的区别

1. 新式类继承于 object ， 旧式类则不一定
2. 新式类的元类是 type ， 旧式类没有元类
3. 新式类继承于 object 是 type 的实例。继承使用 __init__ ，实例使用 __new__ 
4. 新式类的类也有父类和继承关系，旧式类的类没有父类和继承关系，只有在实例化之后才有父类和继承关系
3. 新式类可以使用 super 函数，可以使用 @property 设置属性
4. 新式类有更多的属性和方法

## 装饰器和闭包的联系

装饰器也是经典的设计模式中的一种，也是 Python 中用到的不多的设计模式中的一种。装饰器的常用场景有 
1. 事务处理，如性能分析，日志记录，运行时间记录
2. 验证及运行时检查，如 flask 中的错误钩子，信号接收和权限管理

装饰器的作用就是通过抽离函数中与函数功能本身无关的雷同代码复用或者给无法复用的代码添加复用代码来为函数或者对象添加额外的功能。

闭包是函数式编程的重要部分，它同样提高了代码的可重复使用性。当一个内嵌函数引用其外部作用域的变量，我们就得到一个闭包函数。

## 装饰器和上下文管理器的区别

## Python 字典 dict

Python 字典是一个键值映射关系的集合，底层实现是一个哈希表 (Hash Table) 。

字典是无序的，索引是对键的哈希，故字典中顺序不一定是写入的顺序，也不一定是按照键的大小顺序。

因为需要对键值进行索引，所以并非所有的值都是都可以作为键，只有可哈希的对象才能作为键值，即实现了 __hash__ 函数的对象。 如不可变类型数字和字符串，还有元组也是可哈希的，所以可以作为键值，但是元组的元素必须为数字或者字符串，如果元组的元组有字典或者其他可变数据类型也不可以。

但是在 Python 3.6 及以后，字典的哈希表修改了，在字典中是按照键的顺序存储。

如果想使用按照写入的顺序存储的话，可以使用 collections 里的 OrderDict 

## Python 列表 list

Python 列表是有序的，可以使用序号查找元素，可以使用分片切割列表。

列表可以进行直接乘法和加法运算。

可以直接创建列表，或者列表生成式创建列表，还可以使用列表迭代生成器创建列表。

在遍历列表或者创建列表的时候，可以使用 yield 做迭代器减少内存消耗

## Python 元组 tuple

Python 元组是不可改变的列表，不能改变，不能删除，可以联合，可以截取。

## Python 集合 set

Python 元组是无序的，没有重复元素，元组不能通过序号查找。定义了集合的并交差等操作。

集合不能使用序号查找元素，只能使用 pop 获取元素，是无序的。使用 add 和 remove 增加删减元素。

如果想使用不可改变的集合，可以使用 frozenzet 

## 可迭代对象和迭代器对象

可迭代对象不一定是迭代器对象，迭代
，可迭代对象需要实现 `__iter__` 方法或者 `__getitem__` 方法。

迭代器对象需实现 `next` 或者 `__next__` 方法

## 现代企业工作流程

开发模式 - 快速迭代开发， 开发流程 - gitflow 工作流

开发之前，先确定需求，评估项目可行性，对项目进行版本切分和开发任务划分。

开发时，主开发分支为 develop ，各自负责自己的部分，并新建自己的分支，有问题共同探讨，无问题则合并到 develop 分支。遇到新的需求，先等等，没准过几天就没了，真的需要也得加入到下一个开发版本。

完成开发版本，进入测试阶段，先进行项目的自测，测试驱动开发，使用现代的测试手段，如 nosetest ，pytest 等进行项目测试。

测试都完成之后，进入发版阶段 ，将 develop 分支合并到 release 分支，提供给客户端，或者其他的需求方，完成他们的部分。

在提交给其他部门之后，下一个版本的开发 feature 也要同步进行，如果其他部门遇到问题，则需在主开发分支 develop 上进行修复，修复完成后合并入 release 分支。

在各部门都完成开发测试工作之后，交给测试部门联合测试。继续进行下一版本的开发。

在测试部门测试无误通过后，正式上线，将 release 分支合并到 master 。将下一个版本的开发分支 feature 合并入主开发分支 develop。如果上线后遇到问题，则在 master 分支上做热修复 hot-fix 分支。
